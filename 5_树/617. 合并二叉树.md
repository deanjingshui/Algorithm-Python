## 617. 合并二叉树

`深度优先遍历`

`递归`

`前序遍历二叉树`

`同时遍历2个二叉树`

### 一、思路

这是一道典型的利用 **递归** 实现 **前序遍历二叉树** 的题目。

可以使用深度优先搜索合并两个二叉树，从根节点开始同时遍历两个二叉树，并将对应的节点进行合并。

两个二叉树的对应节点可能存在以下三种情况，对于每种情况使用不同的合并方式：

* 如果两个二叉树的对应节点都为空，则合并后的二叉树的对应节点也为空；

* 如果两个二叉树的对应节点只有一个为空，则合并后的二叉树的对应节点为其中的非空节点；

* 如果两个二叉树的对应节点都不为空，则合并后的二叉树的对应节点的值为两个二叉树的对应节点的值之和，此时需要显性合并两个节点。

对一个节点进行合并之后，还要对该节点的左右子树分别进行合并，这是一个递归的过程。

**综上**

* 首先“做事”，即对当前节点做处理

* 然后，依次遍历左、右子树

符合 **“前序遍历二叉树”** 的模式

### 二、难点：`同时遍历2个二叉树`

刚拿到这道题目，虽然很容易想到同时遍历2个二叉树，但是不知道如何在代码层面做到同时遍历2个二叉树。

之前的题目遍历1个二叉树：

```python
if node is None:
    do something
else:
	dfs(node.right)
	dfs(node.left)
```

现在同时遍历2个二叉树：

```python
if node1 is None:
    do something
if node2 is None:
    do something
if node1 and node2:
	dfs(node1.left, node2.left)
	dfs(node1.right, node2.right)
```

