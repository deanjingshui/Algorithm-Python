## 三数之和

2020.8.9

我使用了”排序“+”双指针“+”记忆化“，依然运行超时

排序+双指针 这个解题思路与标准答案是一致的，超时的根因是在于“去重”的方法上，我采用的是列表的“成员资格判断（即`not in`,`in`）”，而且使用的“记忆化”功能是多余的！



**关键**：

​	1、将列表有序化之后的去重技巧（即相邻元素判断是否相等）

​	2、python中列表的成员资格判断（即`not in`,`in`）效率相对低，推测比字典的要低很多

**思路**：

* 标签：数组遍历

* 首先对数组进行排序，排序后固定一个数 nums[i]，再使用左右指针指向 nums[i]后面的两端，数字分别为 nums[L]和 nums[R]，计算三个数的和 sum 判断是否满足为 0，满足则添加进结果集

* 如果 nums[i]大于 0，则三数之和必然无法等于 0，结束循环

* 如果 nums[i] == nums[i-1]，则说明该数字重复，会导致结果重复，所以应该跳过

* 当 sum == 0 时，nums[L] == nums[L+1] 则会导致结果重复，应该跳过，L++

* 当 sum == 0 时，nums[R] == nums[R-1] 则会导致结果重复，应该跳过，R--

* 时间复杂度：$ O(n^2) $，n为数组长度



**总结**：

遇到“去重”，需要条件反射地想到“排序”。





