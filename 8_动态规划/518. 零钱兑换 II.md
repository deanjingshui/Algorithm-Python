## 518. 零钱兑换 II

这本质是一个“完全背包问题”，也是动态规划问题中的一种类型

### 思路

参考[leetcode](https://leetcode-cn.com/problems/coin-change-2/solution/dong-tai-gui-hua-wan-quan-bei-bao-wen-ti-by-liweiw/)

关于完全背包问题的介绍，大家可以在互联网上搜索《背包九讲》进行相关知识的学习。本题解使用了完全背包问题的描述，因此会不加解释的使用「背包」、「容量」这样的名词。

#### 1、与「力扣」第 377 题（组合总和 Ⅳ）的区别

这道题，第一眼看过去和「力扣」 第 377 题：组合总和 Ⅳ 很像，它们的区别在于 **结果集是否在乎排列顺序**：

* 「力扣」 第 377 题：一个组合的不同排列是一个新的组合。[2, 2, 1]、[1, 2, 2]、[2, 1, 2] 视为不同的组合。
* 「力扣」 第 518 题：**一个组合的不同排列在结果集中只出现一次**，这一点是「背包问题」的特征，拿东西的 **顺序不重要**。[2, 2, 1] 是一个组合，[1, 2, 2] 和 [2, 1, 2] 不是新的组合。这道题和「力扣」第 39 题：组合总和 很像，只不过：
  * 第 39 题问的是所有的组合列表，应该使用 **回溯算法** 求解；
  * 第 518 题问的是组合有多少种，而不是问具体的解。应该使用 **动态规划** 求解。

这道题可以套用「完全背包」的模型，不过我们这里和大家推导一下公式，以加深对「完全背包」模型的理解。

#### 2、复习「完全背包」问题

* 「完全背包」问题的特点是：背包里的物品可以无限次选取；

* 本题特殊的地方在于：从背包里选取的物品 **必须刚好装满** 需要考虑的容量，而不是小于等于，注意这点细微的区别。

「完全背包」问题是「0-1」背包问题的扩展。它们的区别在于：
* 「0-1」背包问题：当前考虑的物品拿或者不拿；

* 「完全」背包问题：当前考虑的物品拿或者不拿，如果拿，只要背包能装下，就可以一直拿，直到背包装不下为止。

求解思路依然是：**一个一个物品考虑，容量一点一点扩大**，整个过程是一个 **尝试** 和 **比较** 的过程。

#### 3、思考状态和状态转移方程
* 第 1 步：定义状态
  
  dp\[i][j]：硬币列表的前缀子区间 [0, i] 能够凑成总金额为 j 的组合数。
  
  说明：背包问题有一个特点，顺序无关，在本题解的最开始，我们强调过这道问题的这个性质，因此可以一个一个硬币去考虑。
  
* 第 2 步：状态转移方程

  对于遍历到的每一种面值的硬币，逐个考虑添加到 「总金额」 中。由于硬币的个数可以无限选取，因此对于一种新的面值的硬币 coins[i]，依次考虑选取 0 枚、1 枚、2 枚，以此类推，直到选取这种面值的硬币的总金额超过需要的总金额 j 为止。

  状态转移方程是：

  ```python
  dp[i][j] = dp[i - 1][j - 0 * coins[i]] + 
             dp[i - 1][j - 1 * coins[i]] +
             dp[i - 1][j - 2 * coins[i]] + 
             ... + 
             dp[i - 1][j - k * coins[i]]
  
  ```
  
  说明：状态转移方程基于「分类计数原理」：完成一件事，有 n 类办法，在第 1 类办法中有 m_1 种不同的方法，在第 2 类办法中有 m_2 种不同的方法，……，在第 n 类办法中有 m_n
  种不同的方法，那么完成这件事共有：N = m_1 + m_2 + ... + m_n 种不同的方法。
  
  上述公式需要满足：j - k * coins[i] >= 0。dp\[i][j] 相对于 dp\[i - 1][j] 而言，多考虑的一枚硬币，是当前正在考虑的那枚硬币的面值，coins[i]，而这枚硬币选取的个数（从 0 开始）就是 dp\[i][j] 这个问题可以分解的各个子问题的分类标准。
  
* 第 3 步：思考初始化

  dp\[0][0] 的值设置为 1，这一点可能比较难理解，但它作为被参考的值，可以使得后续的状态转移方程正确。原因是：当 dp\[i - 1][j - k * coins[i]] 的第 2 维 j - k * coins[i] == 0 成立的时候，k 个硬币 coin[i] 恰好成为了一种组合。因此，dp\[0][0] = 1 是合理的（代入状态转移方程，值正确）。

  填写第 1行（下标为 0 的那一行），也是初始化的时候需要考虑的内容。第 1 行只考虑第 1 枚硬币 coins[0]，能够组合出的容量只有 coins[0] 的整数倍数。

* 第 4 步：思考输出

  输出就是表格的最后一格的数值，即 dp\[len - 1][amount]。

* 第 5 步：考虑空间优化

  当前状态行的值，只和上一行的状态值相关，可以使用滚动数组技巧。

  

作者：liweiwei1419

链接：https://leetcode-cn.com/problems/coin-change-2/solution/dong-tai-gui-hua-wan-quan-bei-bao-wen-ti-by-liweiw/

来源：力扣（LeetCode）



### 总结

ME：这题难点是不容易想到正确的dp表的定义

​	     最开始我的定义的dp[i]的含义：可组成金额为i的组合数

​         状态转移方程：dp[i] = dp[i-coin_1] + dp[i-coin_2] + ... + dp[i-coin_n]

​		  错误：几种前置状态之间可能有重复